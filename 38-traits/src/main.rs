fn main() {
  let r1 = Rect::new(10.12, 12.23);
  let s1 = Square::new(12.23);
 // let k1 = (12,12.13,true);

  call_shape_static(&r1);
  call_shape_static(&s1);

    println!();
  call_shape_dynamic(&r1);
  call_shape_dynamic(&s1);

  println!();

  call_shape_generic1(&r1);
  call_shape_generic1(&s1);

  println!();

  call_shape_generic2(&r1);
  call_shape_generic2(&s1);


  //call_shape(k1);
}

// Rect 
// Square

// Area and Perimeter

trait shape{
    fn area(&self)->f32;
    fn perimeter(&self)->f32;
    fn what(&self)->String;
}

fn call_shape_static<'a>(s:&'a impl shape){    // static dispatch
    println!("Calling using static dispatch"); // monomorphization
    let a = s.area();                     // most ofallocations are on stack
    let p = s.perimeter();                // generate additoncal code during compilation
    let w =  s.what();                 // if the types are not concrete or dynamically added to vectors etc.. this does not work
    println!("Area:{} Perimeter:{} for {}",a,p,w);
}

fn call_shape_generic1<'a,S>(s:&'a S) where S:shape{  // static dispatch,normal generic code
    println!("Calling using static dispatch");        // monomorhpization works
    let a = s.area();                            // code is generated by the compiler for the concrete types
    let p = s.perimeter();
    let w =  s.what();
    println!("Area:{} Perimeter:{} for {}",a,p,w);
}

fn call_shape_generic2<'a,S:shape>(s:&'a S){   // static dispatch,normal generic code with a another syntax
    println!("Calling using static dispatch"); // monomorphization works
    let a = s.area();                     // code is generated by the compiler
    let p = s.perimeter();
    let w =  s.what();
    println!("Area:{} Perimeter:{} for {}",a,p,w);
}

fn call_shape_dynamic<'a>(s: &'a dyn shape){   // dynamic dispatch
    println!("Calling using dynamic dispatch");// there would be little runtime overhead
    let a = s.area();                     // internally uses vtable for each trait
    let p = s.perimeter();                // more heap allocations, as vtable uses heap
    let w =  s.what();                 // non concrete types can also be uses if trait is satisfied
    println!("Area:{} Perimeter:{} for {}",a,p,w);
}


struct Rect{
    l:f32,
    b:f32,
}

impl Rect{
    fn new(l:f32,b:f32)->Self{
        return Rect{l:l,b:b};
    } 
}

impl shape for Rect{
    fn area(&self)->f32{
        return self.l * self.b;
    }
    fn perimeter(&self)->f32{
        return 2.0 * (self.l+self.b)
    }
    fn what(&self)->String{
        return "Rect".to_string();
    }
}

struct Square(f32);

impl Square{
    fn new(s:f32)->Square{
        Self(s)
    }
}

impl shape for Square{
    fn area(&self)->f32 {
        self.0 * self.0
    }
    fn perimeter(&self)->f32 {
        4.0 * self.0
    }
    fn what(&self)->String {
        "Square".to_string()
    }
}

// Trait --> Talk 
// Aninal -> Dog, Cat, Lion
// Implement Talk function for all these tyoes..
// create new function for all thoses and create a general function called talk(ITalk) 
// add generic type of implementation
// impl vs dyn
